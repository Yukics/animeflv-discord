fn main(){
    // sudo apt install libssl-dev
    let response = reqwest::blocking::get(
        "https://www3.animeflv.net/",
    ).send()?;
    let body_response = response.text()?;
    // .unwrap()
    // .text()
    // .unwrap();
    let parsed_html = Html::parse_document(&body_response)
    let selector = &Selector::parse("ul > li > a.fa-play > strong.Title")
        .expect("Error during the parsing using the given selector");
    let span_text = parsed_html
        .select(selector)
        .flat_map(|el| el.text())
        .collect()

    let document = scraper::Html::parse_document(&response);
    let title_selector = scraper::Selector::parse("ul > li > a.fa-play > strong.Title").unwrap().expect("Error during the parsing using the given selector");;
    let title_selector = scraper::Selector::parse("h3.lister-item-header>a").unwrap();
    let titles = document.select(&title_selector).map(|x| x.inner_html());
    println!("{}", &titles)
    titles
        .zip(1..20)
        .for_each(|(item, number)| println!("{}. {}", number, item));
    let size = titles.len();
    titles
        .zip(1..21)
        .for_each(|(item, number)| println!("{}. {}", number, item));
    println!("okay no sale nada {}", span_text);
} 
extern crate reqwest;
extern crate scraper;

// importation syntax 
use scraper::{Html, Selector};

fn main() {
    hn_headlines("https://www3.animeflv.net");
}

async fn hn_headlines(url: &str) {

   let resp = reqwest::get(url).await.unwrap(); 
   assert!(resp.status().is_success());

   let body = resp.text().await.unwrap();
   // parses string of HTML as a document
   let fragment = Html::parse_document(&body);
   // parses based on a CSS selector
   let stories = Selector::parse(".Title").unwrap();

   // iterate over elements matching our selector
   for story in fragment.select(&stories) {
        // grab the headline text and place into a vector
        let story_txt = story.text().collect::<Vec<_>>();
        println!("{:?}", story_txt);
    }
}

use reqwest;

// tokio let's us use "async" on our main function
#[tokio::main]
async fn main() {
    // chaining .await will yield our query result
    let result = reqwest::get("https://www3.animeflv.net").await;
    println!("{:?}", result);
}
extern crate select;
extern crate scraper;

use select::document::Document;
use select::predicate::{Class, Name, Predicate};
use scraper::{Html, Selector};

fn main() {
    hacker_news("https://www3.animeflv.net");
}

fn hacker_news(url: &str) {

    let content = reqwest::get(url).await;

    println!("text: {:?}", content);
    let resp = reqwest::get(url).await.unwrap();
    assert!(resp.status().is_success());

    // let document = Document::from_read(resp).unwrap();
    let body = resp.text().await.unwrap();
    println!("{}", &body);
    let document = Html::parse_document(&body);
    // let document = Document::from(resp.as_bytes()).unwrap();

    // finding all instances of our class of interest
    for node in document.find(Class("athing")) {
        // grabbing the story rank
        let rank = node.find(Class("rank")).next().unwrap();
        // finding class, then selecting article title
        let story = node.find(Class("title").descendant(Name("a")))
            .next()
            .unwrap()
            .text();
        // printing out | rank | story headline
        println!("\n | {} | {}\n", rank.text(), story);
        // same as above
        let url = node.find(Class("title").descendant(Name("a"))).next().unwrap();
        // however, we don't grab text
        // instead find the "href" attribute, which gives us the url
        println!("{:?}\n", url.attr("href").unwrap());
    }
}
extern crate cloudflare_bypasser;
extern crate reqwest;

fn main() {
    quick start
    let mut bypasser = {
        cloudflare_nypasser::Bypasser::new()
    };

    customize
    let mut bypasser = {
        cloudflare_bypasser::Bypasser::new()
            .proxy("http://127.0.0.1:1087") // use proxy, default None
            .random_user_agent(true)        // use random user agent, default false
            .user_agent("Mozilla/5.0")      // specify user agent manually, default ""
            .wait(5);                       // cloudflare's waiting time, but in my test it can be 0, default 0
    };                           

    let (cookie, user_agent);
        loop {
            if let Ok((c, ua)) =  bypasser.bypass("https://www3.animeflv.net") {
                cookie = c;
                user_agent = ua;
                break;
            }
        }
    
    without proxy
    {
        // 1
        {
    let client = {
        let headers = {
            let mut h = reqwest::header::HeaderMap::new();
            h.insert(reqwest::header::COOKIE, cookie);
            h.insert(reqwest::header::USER_AGENT, user_agent);
            h
        };
        
        reqwest::ClientBuilder::new()
            .default_headers(headers)
            .build()
            .unwrap()
    };
        
    let text = client.get("https://example.com")
        .send()
        .unwrap()
        .text()
        .unwrap();
    println!("{}", text);
        }
        
        2
        {
            let text = reqwest::Client::new()
                .get("https://example.com")
                .header(reqwest::header::COOKIE, cookie)
                .header(reqwest::header::USER_AGENT, user_agent)
                .send()
                .unwrap()
                .text()
                .unwrap();
            println!("{}", text);
        }
    }
    
    with proxy
    {
        let client = {
            let headers = {
                let mut h = reqwest::header::HeaderMap::new();
                h.insert(reqwest::header::COOKIE, cookie);
                h.insert(reqwest::header::USER_AGENT, user_agent);
                h
            };
            
            reqwest::ClientBuilder::new()
                .default_headers(headers)
                .proxy(reqwest::Proxy::all("http://127.0.0.1:1087").unwrap())
                .build()
                .unwrap()
        };
            
        let text = client.get("https://example.com")
            .send()
            .unwrap()
            .text()
            .unwrap();
        println!("{}", text);
    }
}